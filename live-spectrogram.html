<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Live Microphone Spectrogram (Scrolling)</title>
<style>
  :root{
    --bg:#0b1020; --panel:#0f1730; --fg:#e8f1ff; --muted:#9fb4d1;
    --accent:#7cd2ff; --line:#1f2a54; --good:#64f0a5; --warn:#ffcc66;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  header,footer{padding:.75rem 1rem;border-bottom:1px solid var(--line);background:linear-gradient(180deg,#101835,#0b1020)}
  footer{border-top:1px solid var(--line);border-bottom:none;background:linear-gradient(0deg,#101835,#0b1020);font-size:.9rem;opacity:.9}
  main{display:grid;grid-template-columns:1fr 320px;gap:12px;padding:12px}
  .panel{background:var(--panel);border:1px solid var(--line);border-radius:12px;padding:12px}
  .row{display:flex;align-items:center;gap:8px;justify-content:space-between;margin:.35rem 0}
  label{font-size:.9rem;color:var(--muted)}
  input[type="range"],select,button{accent-color:#3ea0ff}
  button{background:#152143;color:var(--fg);border:1px solid #2a3d7a;border-radius:.6rem;padding:.5rem .8rem;cursor:pointer}
  button.primary{background:#1a3a6b;border-color:#345ea2}
  #wrap{position:relative}
  #spec{width:100%;height:calc(100vh - 220px);background:#061024;border:1px solid var(--line);border-radius:12px;display:block}
  .axis{position:absolute;pointer-events:none;color:#cfe3ff80;font-size:12px}
  #yticks{left:8px;top:8px}
  #xticks{right:12px;bottom:8px;text-align:right}
  .meter{height:10px;background:#101a38;border:1px solid var(--line);border-radius:999px;overflow:hidden}
  .meter>span{display:block;height:100%;width:0%;background:linear-gradient(90deg,#3a8bd8,#7cd2ff)}
  .hint{color:var(--muted);font-size:.9rem}
</style>
</head>
<body>
<header>
  <div style="display:flex;gap:12px;align-items:center;flex-wrap:wrap">
    <div style="font-weight:700;font-size:1.1rem">Live Mic Spectrogram</div>
    <div class="hint">Scrolling x-axis (time), adjustable FFT and frequency range.</div>
  </div>
  <div style="display:flex;gap:.5rem;flex-wrap:wrap">
    <button id="start" class="primary">‚ñ∂ Start</button>
    <button id="pause">‚è∏ Pause</button>
    <button id="save">üíæ Save PNG</button>
  </div>
</header>

<main>
  <div id="wrap" class="panel" style="position:relative">
    <canvas id="spec" width="1400" height="600" aria-label="Spectrogram canvas"></canvas>
    <div id="yticks" class="axis"></div>
    <div id="xticks" class="axis"></div>
  </div>

  <div class="panel">
    <div style="font-weight:700;margin-bottom:.25rem">Settings</div>

    <div class="row">
      <label for="seconds">Time window (s)</label>
      <input id="seconds" type="range" min="2" max="12" step="1" value="6">
      <span id="secondsVal">6</span>
    </div>

    <div class="row">
      <label for="fft">FFT size</label>
      <select id="fft">
        <option value="1024">1024</option>
        <option value="2048" selected>2048</option>
        <option value="4096">4096</option>
      </select>
    </div>

    <div class="row">
      <label for="fmin">Min freq (Hz)</label>
      <input id="fmin" type="range" min="20" max="2000" step="10" value="100">
      <span id="fminVal">100</span>
    </div>

    <div class="row">
      <label for="fmax">Max freq (Hz)</label>
      <input id="fmax" type="range" min="1000" max="20000" step="100" value="8000">
      <span id="fmaxVal">8000</span>
    </div>

    <div class="row">
      <label for="dyn">Dynamic range (dB)</label>
      <input id="dyn" type="range" min="30" max="120" step="5" value="80">
      <span id="dynVal">80</span>
    </div>

    <div class="row">
      <label for="logy">Log frequency axis</label>
      <input id="logy" type="checkbox" checked>
    </div>

    <div class="row">
      <label>Mic level</label>
      <div class="meter" style="flex:1"><span id="lvl"></span></div>
    </div>

    <div class="hint">Tips: use headphones to avoid feedback ‚Ä¢ raise OS input gain if the image is dark.</div>
  </div>
</main>

<footer>
  <div>WebAudio + Canvas ‚Ä¢ Viridis colormap ‚Ä¢ Crisp STFT frames (no smoothing)</div>
  <div class="hint">All processing is local in your browser.</div>
</footer>

<script>
/* ======== UI elements ======== */
const canvas = document.getElementById('spec');
const ctx     = canvas.getContext('2d', { alpha:false });
const yticks  = document.getElementById('yticks');
const xticks  = document.getElementById('xticks');

const startBtn = document.getElementById('start');
const pauseBtn = document.getElementById('pause');
const saveBtn  = document.getElementById('save');

const seconds   = document.getElementById('seconds');
const secondsVal= document.getElementById('secondsVal');
const fftSel    = document.getElementById('fft');
const fminSl    = document.getElementById('fmin');
const fmaxSl    = document.getElementById('fmax');
const dynSl     = document.getElementById('dyn');
const logyChk   = document.getElementById('logy');
const lvlBar    = document.getElementById('lvl');

secondsVal.textContent = seconds.value;
fminSl.oninput = ()=> (document.getElementById('fminVal').textContent = fminSl.value, rebuildYmap());
fmaxSl.oninput = ()=> (document.getElementById('fmaxVal').textContent = fmaxSl.value, rebuildYmap());
dynSl.oninput  = ()=> (document.getElementById('dynVal').textContent  = dynSl.value);
seconds.oninput = ()=> secondsVal.textContent = seconds.value;
logyChk.onchange = ()=> rebuildYmap();

/* ======== Audio setup ======== */
let audioCtx, analyser, mic, gain;
let freqBins, timeBuf;
let running=false, paused=false;

function viridis(t){
  // t in [0,1] -> RGBA (premultiplied not needed). 256-sample LUT (compact).
  // Coeffs from matplotlib viridis sampled; here we approximate with piecewise polynomials.
  // For simplicity, we use a small lookup we generate once:
  if(!viridis.lut){
    viridis.lut = new Uint8Array(256*3);
    for(let i=0;i<256;i++){
      const x=i/255;
      // polynomial fit (good enough visually)
      const r = 0.2803 + 0.7066*x - 0.4715*x*x + 0.2313*x*x*x;
      const g = 0.0467 + 1.0415*x - 0.6805*x*x + 0.1800*x*x*x;
      const b = 0.4959 + 0.2914*x + 0.1781*x*x - 0.4396*x*x*x;
      viridis.lut[i*3+0] = Math.max(0, Math.min(255, Math.round(255*r)));
      viridis.lut[i*3+1] = Math.max(0, Math.min(255, Math.round(255*g)));
      viridis.lut[i*3+2] = Math.max(0, Math.min(255, Math.round(255*b)));
    }
  }
  const k = Math.max(0, Math.min(255, (t*255)|0));
  const o = 3*k;
  return [viridis.lut[o], viridis.lut[o+1], viridis.lut[o+2]];
}

async function initAudio(){
  if(audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  const stream = await navigator.mediaDevices.getUserMedia({
    audio: {echoCancellation:false, noiseSuppression:false, autoGainControl:false},
    video:false
  });
  mic = audioCtx.createMediaStreamSource(stream);
  gain = audioCtx.createGain();
  analyser = audioCtx.createAnalyser();
  setAnalyserFFT(+fftSel.value);
  analyser.smoothingTimeConstant = 0.0; // crisp frames for spectrogram
  analyser.minDecibels = -110;          // base floor; user dynamic range applies
  analyser.maxDecibels = -10;

  mic.connect(gain).connect(analyser);
}

function setAnalyserFFT(fftSize){
  if(!audioCtx) return;
  analyser.fftSize = fftSize;
  freqBins = new Float32Array(analyser.frequencyBinCount);
  timeBuf  = new Float32Array(analyser.fftSize);
  rebuildYmap();
}

/* ======== Y-axis bin map (supports log or linear) ======== */
let y2bin = null, y2frac = null; // for linear interpolation
function rebuildYmap(){
  if(!audioCtx || !analyser) return;
  const H = canvas.height|0;
  y2bin  = new Float32Array(H);
  y2frac = new Float32Array(H);

  const fmin = +fminSl.value;
  const fmax = +fmaxSl.value;
  const sr   = audioCtx.sampleRate;
  const binHz = sr / analyser.fftSize;

  for(let y=0;y<H;y++){
    const t = y/(H-1);          // 0 top -> 1 bottom
    const f = logyChk.checked
      ? fmax * Math.pow(fmin/fmax, t)   // log scale, top=fmax
      : fmax - t*(fmax - fmin);         // linear
    const idx = Math.max(0, Math.min(analyser.frequencyBinCount-1, f/binHz));
    const i0 = Math.floor(idx), i1=Math.min(i0+1, analyser.frequencyBinCount-1);
    y2bin[y]  = i0;
    y2frac[y] = idx - i0;
  }
  drawYTicks();
}

/* ======== Drawing helpers ======== */
function drawYTicks(){
  const H = canvas.height|0;
  const fmin = +fminSl.value, fmax = +fmaxSl.value;
  const ticks = logyChk.checked
    ? [100,200,300,500,1000,2000,3000,5000,8000,12000,16000,20000].filter(f=>f>=fmin && f<=fmax)
    : Array.from({length:6}, (_,k)=> Math.round(fmin + k*(fmax-fmin)/5));

  let html = '';
  for(const f of ticks){
    const pos = logyChk.checked
      ? (Math.log(fmax) - Math.log(f)) / (Math.log(fmax)-Math.log(fmin))
      : (fmax-f)/(fmax-fmin);
    const y = Math.round(pos*(H-1))+8;
    html += `<div style="position:absolute;left:0;top:${y}px;">${f>=1000?(f/1000).toFixed(f%1000?1:0)+'k':f} Hz</div>`;
  }
  yticks.innerHTML = html;
}

function drawXTicks(){
  const W = canvas.width|0;
  const secs = +seconds.value;
  const now  = performance.now()/1000;
  const tps  = W/secs; // px per second
  // Draw 1s grid labels (right aligned)
  const maxTicks = Math.min(secs, 12);
  let html = '';
  for(let s=0;s<=maxTicks;s++){
    const x = W - Math.round(s*tps);
    html += `<div style="position:absolute;right:0;bottom:${8+16*s}px;">${s}s</div>`;
  }
  xticks.innerHTML = html;
}

/* ======== Spectrogram renderer ======== */
const colBuf = new Uint8ClampedArray((canvas.height|0) * 4); // 1px column buffer
let lastTime = performance.now();
let pxAccum = 0; // how many px columns to draw

function step(nowMs){
  const now = nowMs || performance.now();
  if(running && !paused){
    const dt = (now - lastTime) / 1000; // seconds
    const pxPerSec = (canvas.width|0) / (+seconds.value);
    pxAccum += dt * pxPerSec;

    // Read one FFT frame
    analyser.getFloatFrequencyData(freqBins);
    analyser.getFloatTimeDomainData(timeBuf);
    // Mic meter
    let rms=0; for(let i=0;i<timeBuf.length;i++){ const v=timeBuf[i]; rms+=v*v; }
    rms = Math.sqrt(rms/timeBuf.length);
    lvlBar.style.width = Math.max(0, Math.min(100, 100*(rms/0.2))) + '%';

    // How many columns to draw this frame?
    const cols = Math.floor(pxAccum);
    if(cols>0){
      pxAccum -= cols;

      // Precompute intensity column once; reuse for multiple px if cols>1
      const dyn = +dynSl.value;
      const dbMax = analyser.maxDecibels;
      const dbMin = dbMax - dyn;

      const H = canvas.height|0;
      for(let y=0;y<H;y++){
        const i0 = y2bin[y]|0;
        const t  = y2frac[y];
        const v0 = freqBins[i0] ?? dbMin;
        const v1 = freqBins[i0+1] ?? v0;
        const db = v0*(1-t) + v1*t;           // linear interp in dB
        let u = (db - dbMin) / (dbMax - dbMin); // 0..1
        u = Math.max(0, Math.min(1, u));
        const [r,g,b] = viridis(u);
        const o = ((H-1-y)<<2);
        colBuf[o+0]=r; colBuf[o+1]=g; colBuf[o+2]=b; colBuf[o+3]=255;
      }
      const img = new ImageData(colBuf, 1, H);

      // Shift left and paint new columns
      for(let k=0;k<cols;k++){
        ctx.drawImage(canvas, -1, 0);                     // scroll left by 1 px
        ctx.putImageData(img, canvas.width-1, 0);         // draw new column at right
      }
    }
    lastTime = now;
  }

  // subtle grid overlay
  drawGridOverlay();
  requestAnimationFrame(step);
}

function drawGridOverlay(){
  const W = canvas.width|0, H = canvas.height|0;
  ctx.save();
  ctx.globalAlpha = 0.1;
  ctx.strokeStyle = '#ffffff';
  ctx.lineWidth = 1;
  // horizontal lines every ~100 px
  for(let y=100; y<H; y+=100){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }
  // vertical 1s marks
  const tps = W/(+seconds.value);
  for(let x=W; x>=0; x-=tps){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
  ctx.restore();
}

/* ======== Controls ======== */
startBtn.onclick = async () => {
  try{
    await initAudio();
    audioCtx.resume();
    running=true; paused=false;
  }catch(e){
    alert('Microphone access failed: '+e.message);
  }
};

pauseBtn.onclick = () => {
  if(!audioCtx) return;
  paused = !paused;
  pauseBtn.textContent = paused ? '‚ñ∂ Resume' : '‚è∏ Pause';
};

saveBtn.onclick = () => {
  const a = document.createElement('a');
  a.download = 'spectrogram.png';
  a.href = canvas.toDataURL('image/png');
  a.click();
};

fftSel.onchange = () => setAnalyserFFT(+fftSel.value);
seconds.onchange = () => drawXTicks();

window.addEventListener('resize', ()=> setTimeout(()=>{ drawXTicks(); drawYTicks(); }, 50));

/* ======== Init ======== */
rebuildYmap();
drawXTicks();
lastTime = performance.now();
requestAnimationFrame(step);
</script>
</body>
</html>
